
## 結論

以下內容透過確認清單檢查後匯總

### 通用

- [x] [code]遊戲邏輯 "最高累計贏分值" 判斷
    [確認]設定檔已有 `MaxWinLimit` 遊戲邏輯尚未利用該參數進行 "最高累計贏分值" 判斷。經過我與 Ryan 確認，需要在 "一次 spin" 中檢查 "累積贏分" 是否大於 "最高累計贏分值" 若超過就強制結束。並以 "最高累計贏分值" 結算。

  - 設定檔有 "最高累積贏分值"
  - 確認是倍數達到上限就離開遊戲 還是倍數"最高"只會到X(可繼續遊戲)

    參考需求文件:
    <div style="text-align:center">
  <img src="https://hackmd.io/_uploads/H1ZELZxG-x.png"         style="width:50%;">
        <p>圖 1 流程圖(點擊圖放大)</p>
    </div>
    <div style="text-align:center">
  <img src="https://hackmd.io/_uploads/ryKAzyyz-x.png"         style="width:80%;">
        <p>圖 2 需求文件FG算分描述(點擊圖放大)</p>
    </div>
    <div style="text-align:center">
  <img src="https://hackmd.io/_uploads/By7pI-ez-l.png"         style="width:80%;">
        <p>圖 3 需求文件最高累計贏分值描述(點擊圖放大)</p>
    </div>

    [方案] 在 `game1801` 添加 `maxWinLimit` 和 `totalWin` 屬性值。並且分別在 `getBaseResult` 和 `getFreeResult` 添加判斷邏輯。

    Base Game 達到最高累積贏分值後不需要在判斷 `g.trigger(screen)` 極端情況下，BG spin 達到最高累積贏分值且同時出現觸發 FG 條件，則遊戲依然會進入到 FG 當中，並在 FG 的最高累積贏分值判斷邏輯中跳出。所以會出現 FG Spin 1 次但是 0 分的情況發生。

    ```go=
    type game1802 struct {
        maxWinLimit int // 最高累積贏分值
        accWin    int // 累積贏分值
    }
    
    func buildGame1802(gh *GameHandler) gameLogic {
        // 其他省略
        g1802 := &game1802{
            // 其他省略
            
            maxWinLimit: 0, // 最高累積贏分值
         accWin:    0, // 累積贏分值
        }
    }

    func (g *game1310) reset() {
        g.accWin = 0 // 重置
    }
    ```

    ```go=
    func (g *game1802) getResult(betMode int, betMult int, gh *GameHandler) *result.SpinResult {
        g.maxWinLimit = gh.gameSetting.MaxWinLimit * betMult // 最高累計贏分值
        g.totalWin = 0                                       // 重置累積贏分值
        
        // 其他略
    }
    ```

    `getBaseResult` 和 `getFreeResult` 更新 `totalWin` 並且與 `maxWinLimit` 進行比對

    ```go=
    // Base Game
    func (g *game1801) getBaseResult(betMode int, betMult int, gh *GameHandler) *res.GameModeResult {
        
    
        // 其他步驟省略
        
        // 5. 有贏分: 算乘倍
     mult := g.getBaseMulti(fix.screen, betMode, gh.core, ext)
        
     if mult > 0 {
         win *= mult
     }

        // 判斷 "累積贏分" 是否大於 "最高贏分上限值"
        // **注意等號，如果沒有等號，剛好達到滿倍時會再走一輪0分**
        if (g.accWin + win) >= g.maxWinLimit {
            gmr.UpdateTmpWin(g.maxWinLimit - g.accWin) // 更新分數
            gmr.FinishAct("MaxWin", screen, ext)       // 落地
            gmr.FinishStep()                           // 落地
            break                                      // 上限退出
        }
        
        g.accWin += win // 更新累積贏分
     gmr.UpdateTmpWin(win)
        gmr.FinishAct("GenAndCalcScreen", screen, ext)
        
        // 其他步驟省略
    }

    // Free Game
    func (g *game1801) getFreeResult(betMode int, betMult int, gh *GameHandler) *res.GameModeResult {      

        for i := 0; i < nowLimitRounds; i++ {
            // 掉落消除
            for range 100 {
                
                // 其他步驟省略 
                
                // 外層先判斷是否 g.totalWin > 0 
                if g.totalWin > 0 {
                    if mult > 0 {
                        nowTotalMult += mult // 更新累積乘數
                        win *= nowTotalMult  // 更新贏分

                        g.totalWin += win // 更新累積贏分
                    }


                    // 判斷 "累積贏分" 是否大於 "最高贏分上限值"
                    // **注意等號，如果沒有等號，剛好達到滿倍時會再走一輪0分**
                    if g.totalWin >= g.maxWinLimit {
                        win = win - (g.totalWin - g.maxWinLimit) // 只給到最高累積贏分
                        gmr.UpdateTmpWin(win)
                        break // 早停機制

                    }
                }
                    
            }
                
            gmr.UpdateTmpWin(win)
                
            // 其他步驟省略 
        }
    }

    ```

### Base Game

- [x] [設定檔]特殊購買，在 BG 中花 100 倍下注額，強制下一局 BG spin 盤面生成至少 4 顆 Scatter(C1)

  - 性能問題：建議直接透過設定檔完成(權重+多表)

    [確認]
    [方案] 參考上述建議，權重設定 + 多組輪帶表，並且在設定檔 Fixed 的 BaseStartReel 添加該輪帶表。

    ``` yaml=
    GameModeSettingList:
        GenScreenSetting:
            ReelStripsGroup:
                - # ReelStrip[2]
                weight : 1
                reels :
                    - # Reel[0]
                      symbols : [6,7,6,7,7,2,7,6,7]
                      weights : [0,1,1,1,1,1,0,0,0]                 
                    - # Reel[1]
                      symbols : [6,7,6,7,7,2,7,6,7]
                      weights : [0,1,1,1,1,1,0,0,0]                    
                    - # Reel[2]
                      symbols : [6,7,6,7,7,2,7,6,7]
                      weights : [0,1,1,1,1,1,0,0,0]                
                    - # Reel[3]
                      symbols : [6,7,6,7,7,2,7,6,7]
                      weights : [0,1,1,1,1,1,0,0,0]            
                    - # Reel[4]
                      symbols : [6,7,6,7,7,6,7,6,7]
                      weights : [1,1,1,1,1,1,1,1,1]   
                    - # Reel[5]
                      symbols : [6,7,6,7,7,6,7,6,7]
                      weights : [1,1,1,1,1,1,1,1,1] 
                - # ReelStrip[3]
                weight : 1
                reels :
                    - # Reel[0]
                      symbols : [6,7,6,7,7,6,7,6,7]
                      weights : [1,1,1,1,1,1,1,1,1]                 
                    - # Reel[1]
                      symbols : [6,7,6,7,7,2,7,6,7]
                      weights : [0,1,1,1,1,1,0,0,0]                    
                    - # Reel[2]
                      symbols : [6,7,6,7,7,2,7,6,7]
                      weights : [0,1,1,1,1,1,0,0,0]                
                    - # Reel[3]
                      symbols : [6,7,6,7,7,2,7,6,7]
                      weights : [0,1,1,1,1,1,0,0,0]            
                    - # Reel[4]
                      symbols : [6,7,6,7,7,6,7,6,7]
                      weights : [1,1,1,1,1,1,1,1,1]   
                    - # Reel[5]
                      symbols : [6,7,6,7,7,2,7,6,7]
                      weights : [0,1,1,1,1,1,0,0,0] 
                - # ReelStrip[4]
                weight : 1
                reels :
                    - # Reel[0]
                      symbols : [6,7,6,7,7,2,7,6,7]
                      weights : [0,1,1,1,1,1,0,0,0]                 
                    - # Reel[1]
                      symbols : [6,7,6,7,7,6,7,6,7]
                      weights : [1,1,1,1,1,1,1,1,1]                    
                    - # Reel[2]
                      symbols : [6,7,6,7,7,2,7,6,7]
                      weights : [0,1,1,1,1,1,0,0,0]                
                    - # Reel[3]
                      symbols : [6,7,6,7,7,2,7,6,7]
                      weights : [0,1,1,1,1,1,0,0,0]            
                    - # Reel[4]
                      symbols : [6,7,6,7,7,2,7,6,7]
                      weights : [0,1,1,1,1,1,0,0,0]  
                    - # Reel[5]
                      symbols : [6,7,6,7,7,6,7,6,7]
                      weights : [1,1,1,1,1,1,1,1,1] 
    
    Fixed:
        # Mode:1 BuyFeaureFree
        BetMode: 1
        BaseStartReel: [2,3,4]
        BaseFillReel: 1
        
    ```

    現在 `GenScreenByAssignedReelStrip()` 是用指定的那組輪帶表，依照權重選擇停格因此無須修改遊戲邏輯。

### Free Game

- [x] [設定檔]定義 FG "累加總倍數上限值" 51000 倍
    [確認]
    [方案]在設定檔的 `Fixed` layer 添加 `MultipilerLimit: 51000`
- [x] [code]"累加總倍數上限值" 在遊戲邏輯實作上限判斷
    [確認]
    [方案] 依序執行以下操作
    1. 遊戲邏輯的 `fixed1801` struct 添加 ```MultipilerLimit int `yaml:"MultipilerLimit"` ``` 屬性。
    2. `getFreeResult` 函數步驟 5 添加判斷當前累加總倍數 是否大於 `g.fixed.MultipilerLimit`
    3. 可以繼續進行遊戲

    ```go=
 // 5. 計算乘倍
 mult := g.getFreeMulti(fixed.screen, betMode, gh.core, ext)

 if mult > 0 {
  nowTotalMult += mult // 更新累積

  // 判斷 nowTotalMult 是否大於 "累加總倍數上限值"
  if nowTotalMult >= g.fixed.MultipilerLimit {
   nowTotalMult = g.fixed.MultipilerLimit
  }
  win *= nowTotalMult
 }    
    ```

## 修改過程遇到的新問題

完整程式碼連結: <https://github.com/cgit6/problab/blob/main/internal/engine/game/game_1801_stromofseth.go>

- [ ] `getBaseResult` 在判斷 "最高累積贏分值" 時是否不該用 `break` ?
`break` 會跳出掉落消除流程。接著做 Trigger 判斷，當很極端的情況下 BG spin 同時遇到 `(g.accWin + win) >= g.maxWinLimit` 跟 `Trigger = true` 的情況下，依然觸發 FG。

    [方案] 將 `break` 替換成 `gmr.FinishRound()` 與 `return mode.YieldResult()` 直接返回。

```go=
   if mult > 0 {
   win *= mult
  } 
  // 判斷 "累積贏分" 是否大於 "最高贏分上限值"
  // **注意等號，如果沒有等號，剛好達到滿倍時會再走一輪0分**
  if (g.accWin + win) >= g.maxWinLimit {
   gmr.UpdateTmpWin(g.maxWinLimit - g.accWin) // 更新分數
   gmr.FinishAct("MaxWin", screen, ext)       // 落地
   gmr.FinishStep()                           // 落地
   gmr.FinishRound()                          // 上限退出
   return mode.YieldResult()                  // 返回
  } 
  g.accWin += win // 更新累積贏分
  gmr.UpdateTmpWin(win) 
  // 6. 提交得分的 Act 結果
  gmr.FinishAct("GenAndCalcScreen", screen, ext)
  ext = g.next()   
```

- [ ] 需要再次釐清 `getFreeResult` 需要 `if g.accWin > 0` 的原因? 這是目前 `getFreeResult` 函數修改後的結果(到第五步) 包含 "最高累積贏分" 與 "最高乘數上限" 檢查。

```go=
func (g *game1801) getFreeResult(betMode int, betMult int, gh *GameHandler) *result.GameModeResult {
    // 略
 for i := 0; i < nowLimitRounds; i++ {

  for range 100 {

   // 4. 如果沒贏分退出(step結束)
   if win == 0 {
    gmr.FinishStep()
    gmr.FinishAct("GenAndCalcScreen", screen, nil)
    break
   }

   // 5. 計算乘倍
   mult := g.getFreeMulti(fixed.screen, betMode, gh.core, ext)

   if g.accWin > 0 {

    // 更新贏分相關參數
    if mult > 0 {
     nowTotalMult += mult // 更新累積乘數

     // 判斷 nowTotalMult 是否大於 "累加總倍數上限值"
     if nowTotalMult >= g.fixed.MultipilerLimit {
      nowTotalMult = g.fixed.MultipilerLimit
     }

     win *= nowTotalMult // 更新贏分

    }

    // 判斷 "累積贏分" 是否大於 "最高贏分上限值"
    // **注意等號，如果沒有等號，剛好達到滿倍時會再走一輪0分**
    if (g.accWin + win) >= g.maxWinLimit {
     gmr.UpdateTmpWin(g.maxWinLimit - g.accWin) // 最高
     gmr.FinishRound()
     return mode.YieldResult()
    }
   }
            
   g.accWin += win
   gmr.UpdateTmpWin(win)

```

## LUT 命名調整問題
<!-- LUT 是 weight 透過 sampler.BuildLookUpTable() 轉換過後的 "索引清單" -->
- [問題] 變數名稱語意與實際執行的轉存流程衝突。
  [方案] 目前選擇參考 `game_1310_vikingage` 處理流程與命名方式。執行 "調整設定檔命名" 與 "調整遊戲邏輯" 兩步驟。
  - 步驟1: 在 `yaml` 檔命名更新:
        1.`BaseStartReel` 更新為 `BaseStartReelWeight` 明確表示為權重。
        2.`BaseFillReel` 更新為 `BaseFillReelWeight` 同上。
        3.`FreeStartReel` 更新為 `FreeStartReelWeight` 同上。
        4.`FreeFillReel` 更新為 `FreeFillReelWeight` 同上。
        5.確認其他命名是否需要調整

    ```go=
    # game_1801_stormofseth.yaml

    # 其他省略...

    # 額外設定
    # 額外設定
    Fixed:
      FreeGameRounds: 15
      RetriggerRounds: 5
      FreeMaxRounds: 100
      MultipilerLimit: 51000
      Multipilers: [2,3,4,5,6,8,10,12,15,20,25,50,100,150,200,250,500]
      BetModes:
        - # Mode:0 Normal
          BetMode: 0
          BaseStartReelChooseWeight: [1,1,0,0,0]
          BaseFillReelChooseWeight: [1,1,0,0,0]
          FreeStartReelChooseWeight: [1,1]
          FreeFillReelChooseWeight: [1,1]
          BaseMultiProb: [100,100,100,100,100,80,80,60,60,50,50,30,30,20,15,10,5]
          BaseMultiLvUp: [100,100,100,100,100,80,80,60,60,50,50,30,30,20,15,15,0]
          FreeMultiProb: [50,50,50,50,50,110,110,90,90,80,80,50,50,40,25,15,10]
          FreeMultiLvUp: [120,120,120,120,120,60,60,60,50,50,50,30,30,20,15,15,0]
        - # Mode:1 BuyFeaureFree
          BetMode: 1
          BaseStartReelChooseWeight: [0,0,1,1,1]
          BaseFillReelChooseWeight: [0,0,1,1,1]
          FreeStartReelChooseWeight: [1,1]
          FreeFillReelChooseWeight: [1,1]
          BaseMultiProb: [100,100,100,100,100,80,80,60,60,50,50,30,30,20,15,10,5]
          BaseMultiLvUp: [100,100,100,100,100,80,80,60,60,50,50,30,30,20,15,15,0]
          FreeMultiProb: [50,50,50,50,50,110,110,90,90,80,80,50,50,40,25,15,10]
          FreeMultiLvUp: [120,120,120,120,120,60,60,60,50,50,50,30,30,20,15,15,0]
    ```

  - 步驟2: 遊戲邏輯:
        1. `BetMode1801` 屬性名稱更新明確表示為權重。如 `BaseStartReelChooseWeight` ，型別為 `[]int`。
        2. `buildGame1801` 函數對 `betModes1801` 結構賦值時利用 `sampler.BuildLookUpTable()` 將 "Weight" 轉換為 "LUT" 存入 `betModes1801` 結構
        3. `betModes1801` 屬性名稱尾明確標示 Lut 表示轉換後屬性值，屬性型別為 `sampler.LUT`。

    ``` go=
    // game_1801_stromofseth.go
    func buildGame1801(g *GameHandler) gameLogic {

        // 其他省略...

        // 設定檔 weight 轉存為 Lut
        for d := 0; d < len(g.BetUnit); d++ {
            f.betmodes[d] = betModes1801{
                betMode:          d,
                baseStartReelLut: sampler.BuildLookUpTable(f.BetModes[d].BaseStartReelChooseWeight), // 將權重轉換為 Lut
                baseFillReelLut:  sampler.BuildLookUpTable(f.BetModes[d].BaseFillReelChooseWeight),  // 同上
                freeStartReelLut: sampler.BuildLookUpTable(f.BetModes[d].FreeStartReelChooseWeight),
                freeFillReelLut:  sampler.BuildLookUpTable(f.BetModes[d].FreeFillReelChooseWeight),
                baseMultiProbLut: sampler.BuildLookUpTable(f.BetModes[d].BaseMultiProb),
                baseMultiLvUpLut: sampler.BuildLookUpTable(f.BetModes[d].BaseMultiLvUp),
                freeMultiProbLut: sampler.BuildLookUpTable(f.BetModes[d].FreeMultiProb),
                freeMultiLvUpLut: sampler.BuildLookUpTable(f.BetModes[d].FreeMultiLvUp),
            }
        }

        // 其他省略... 
    }

    // 讀設定檔，目前狀態是 Weight 不是 LUT
    type BetMode1801 struct {
        BetMode                   int   `yaml:"BetMode"`
        BaseStartReelChooseWeight []int `yaml:"BaseStartReelChooseWeight"`
        BaseFillReelChooseWeight  []int `yaml:"BaseFillReelChooseWeight"`
        FreeStartReelChooseWeight []int `yaml:"FreeStartReelChooseWeight"`
        FreeFillReelChooseWeight  []int `yaml:"FreeFillReelChooseWeight"`
        BaseMultiProb             []int `yaml:"BaseMultiProb"`
        BaseMultiLvUp             []int `yaml:"BaseMultiLvUp"`
        FreeMultiProb             []int `yaml:"FreeMultiProb"`
        FreeMultiLvUp             []int `yaml:"FreeMultiLvUp"`
    }

    // 將 Weight 轉換成 LUT
    type betModes1801 struct {
        betMode          int         // 押注模式
        baseStartReelLut sampler.LUT // 主遊戲起始輪id LUT表
        baseFillReelLut  sampler.LUT // 主遊戲遞補輪id
        freeStartReelLut sampler.LUT
        freeFillReelLut  sampler.LUT
        baseMultiProbLut sampler.LUT
        baseMultiLvUpLut sampler.LUT
        freeMultiProbLut sampler.LUT
        freeMultiLvUpLut sampler.LUT
    }

    ```

### 待修正

- 如果同一次 "生成盤面" 跟 "補盤" 都要用同一組 "輪帶表" 那就不需要在設定檔做補盤的輪帶。
- `baseMultiProb` 、 `baseMultiLvUp` 、 `freeMultiProb` 、 `freeMultiLvUp` 需要LUT 嗎?
- 選擇輪帶表用 `Pick()` 就好，不用 `getBaseStartReelIdx()`
- "生成盤面" 跟 "補盤" 都要用同一組 "輪帶表" 那選擇的那組輪帶表就保存在一個變數就好了，不用選兩次。

<!-- ## 昨天最後討論的問題

* 生成盤面用輪帶表 1 時，綁定補盤也要用輪帶表 1  

目前輪帶表規劃如下
 -->
<!-- 
## 確認清單
以下列出的清單逐一檢查遊戲邏輯實作進度
### 基本規格
- [x] [設定檔]設定檔中盤面大小 6 x 5
    [確認]GameModeSetting 0-1 的 ScreenSetting columns = 6, rows = 5 
- [x] [設定檔]掉落消除、任意位置支付
    [確認]HitSetting > betType > BetTypeCollect
- [x] [設定檔]圖標符號 一種 Scatter(C1)、Multiplier (S1) H1-H4,L1-L5
    [確認]SymbolSetting > symbolUsed
- [x] [設定檔]觸發 FG 條件 4 顆以上觸發 15 次 FG spins
    [確認]Fixed FreeGameRounds = 15
- [x] [設定檔]FG 中出現 3-6 C1 觸發 +5 局 free spins，FG 最多 100 局
    [確認]Fixed > FreeMaxRounds 100
- [ ] [設定檔]特殊購買，花 100 倍下注額，必定觸發 4 C1 (15 次 FG spins)
     ==<< 不在code，改設定檔==
- [x] [設定檔]Fix 1: Multiplier symbol(S1) 這回合贏分 x 2-500 倍
    [確認]Fixed > Multipilers
- [ ] [code]Fix 2: 在 FG 期間，累加總倍數，累加總倍數可以在下一回合中獎時加上該回合乘數後乘上該回合贏分，就是這回合的總贏分。
    [確認]nowTotalMult，觸發更新 ==nowTotalMult 的條件要確認一下==，是不是能滿足盤面得分符號 + mult > 0

### Base Game
- [x] [設定檔]6x5 盤面 cols x rows
- [x] [code]消除後(一次 Act)，上方圖標於同軸由上而下掉落補位
    [確認]CalcScreen 找出命中 -> gravity() 消除＋掉落 -> fillScreen() 補盤
- [x] [code]得分計算: 下注額(UnitBet) x 圖標賠率(Pay) x 倍率參數(Multiplier)
 [確認]CalcScreen() -> payTable×betMult 
- [x] [code]贏分計算: 得分計算 x sum(Multiplier symbol) 
    [確認]得分計算之後再乘上乘倍(getBaseMulti/getFreeMulti)
- [x] [code]sum(Multiplier symbol): 可能是一個防呆，該值最小是 1
    [確認]邏輯略微不同但結果一致
- [ ] [設定檔]定義 "最高累計贏分值" 10000 倍，並實作遊戲邏輯
==<<已經有了，確認實作問題==
- [x] [設定檔]輪帶表設計，有 n 組
    [確認]用於補盤

#### Fix 1 Multiplier symbol(S1)
- [x] [設定檔]輪帶表中有 Multiplier symbol(S1) 這一種圖標
- [x] [設定檔]Multiplier symbol 可以出現的乘倍數值
- [x] [code]如果有出現乘數符號的贏分計算 = sum(得分符號贏分) x sum(Multiplier symbol)
    [確認] 
    win := gmr.GetTmpWin() 取得當前總贏分。
    getBaseMulti(...) 獲得乘數符號累加
    執行 win *= mult
- [x] [設定檔]乘倍符號的倍數值依照預先定義的權重來做選擇
    [確認]Fixed > BetModes > BaseMultiProb
- [x] [code]每次得分符號消除後(一個 Act)有概率使盤面上的 Multiplier symbol(S1) 升級至下一個階段
    [確認]FG getFreeResult 同樣第 7 步：邏輯一致，但用 FreeMultiLvUp。
- [x] [設定檔]設定檔中有 "跳下一階段觸發機率" 依照倍數值有對應的權重
    [確認]Fixed > BetModes > BaseMultiLvUp / FreeMultiLvUp
- [x] [設定檔]Multiplier symbol 參數

```
main normal
倍率清單
[2,3,4,5,6,8,10,12,15,20,25,50,100,150,200,250,500]
倍率值出現機率
[10,10,10,10,10,8,8,6,6,5,5,3,3,2,1.5,1,0.5]
倍率值升級機率
```

```
free normal
倍率清單
[2,3,4,5,6,8,10,12,15,20,25,50,100,150,200,250,500]
倍率值出現機率
[10,10,10,10,10,8,8,6,6,5,5,3,3,2,1.5,1,0.5]
倍率值升級機率
[10,10,10,10,10,8,8,6,6,5,5,3,3,2,1.5,1.5,0]
```

```
free Buy Free game
倍率清單
[2,3,4,5,6,8,10,12,15,20,25,50,100,150,200,250,500]
倍率值出現機率
[5,5,5,5,5,11,11,9,9,8,8,5,5,4,2.5,1.5,1]
倍率值升級機率
[12,12,12,12,12,6,6,6,5,5,5,3,3,2,1.5,1.5,0]
```

[確認] 設定檔已設定
### Free Game

- [x] [code]觸發 FG 條件 Scatter(C1) 在當前盤面上出現 4 顆以上
    [確認] base.Trigger 判斷
- [x] [設定檔]初始 FG 局數固定為 15 局
- [x] [設定檔]定義 FG 次數上限
    [確認]FreeMaxRounds
- [x] [設定檔]特殊購買，在 BG 中花 100 倍下注額(UnitBet)，強制在下一局 BG spin 在盤面觸發 至少 4 顆 Scatter(C1)
- [ ] [code]FG 期間的 "最高累計贏分值" 當 FG 累積的贏分大於 "最高累計贏分值" 直接結束遊戲，並以 "最高累計贏分值" 結算。
    [確認]目前 FG 沒有任何 "最高累計贏分值" 的上限判斷，也不會在 "累計贏分值" 超過 "最高累計贏分值" 時提前結束 FG。
    [方案]需要在 FG 回圈裡每次累加後檢查總贏分，超過就強制結束。
- [x] [設定檔]定義上限倍數值

#### Fix 2 累加總倍數
- [x] [code]乘數圖標只在 FG 中累加
- [x] [code]"執行累加總倍數更新"的條件，當局有出現 "得分符號贏分" 以及出現 "乘數符號" 時觸發執行累加總倍數更新，也就是只有在當前盤面 有得分符號贏分 + 出現乘倍符號 的情況下才會 "執行累加總倍數更新" 如果只現 "乘數符號" 或是只出現 "得分符號贏分" 都不會 "執行累加總倍數更新"
    [確認]已實作
- [x] [code]FG 贏分計算 = sum(得分符號贏分) x (當局乘數圖標加總 + 累加總乘數)
    [確認]已實作
- [ ] [設定檔]定義 "累加總倍數上限值" 51000 倍
    [確認]尚未設定
- [x] [code]累加總倍數在 FG 結束後初始化為 0

## 問 ryan
[連結](https://hackmd.io/@chiSean/SJxHD3CZbe)

 -->