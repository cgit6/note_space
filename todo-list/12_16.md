# 12/16 任務清單

## 摘要

延續昨天接收到的 `problab` 版本更新消息，對 AddAct、extend 做處理

## 代辦清單

- [ ] debug 昨天改 gravity 可能會產生問題，懷疑 C1 不會被消除。(有可能下方調整完之後 這個問題就不存在了?)
      [方案]
      所以需要進 debug 模式確認結果。那怎樣的數值才是對的?
      我現在 payTable 將 C1 的部分獨立拆出來放在 `Fixed` 的 `ScatterPay` ，但是這樣會有問題，C1 的賠率不會在"消除掉落" 階段被記入，所以需要補上 C1 算分函數，在。這個函數會將獲取到的 C1 顆數當作索引值到清單中進行查找，返回賠率。這個函數放在 `fixed` 的方法中。不然就是要消除掉落的時候 `gravity()` 不能消除 C1，不然永遠都不會觸發 FG

- [ ] 現在遇到一個 C1 算分時機的問題，會牽涉到 acts 如何安排，C1 應該在消除掉落計算還是消除掉落外?
      [情境]
      如果盤面一開始已經出現 4 個 Scatter 了(有賠率)，然後經過一番消除掉落，某一次消除掉落又蹦出 1 個 Scatter (賠率更高了)，然後繼續消除掉落數次，結束這回合。
      [問題]
      那 Scatter 的計分表演是在所有消除掉落結束後還是出現的時候就要表演?
      [觀察]
      我看維京有中獎就會閃紅光對吧?但因為 Scatter 卡在他不會消失，所以他每次都會一直閃，那 Scatter 算分數字跳動的時機是什麼時候跳動?因為如果它出 4 顆的時候表演一次 那 再出一顆的時候怎麼辦?
      [Ryan]
      我的建議是直接在輪帶設置那邊掐死，如果這次的掉落補位或旋轉足以觸發 FG 的話就不給予其他得分組合，我猜這就是賽特不太會出現同時得分跟 SCATTER 的原因。
      但如果打算成立這個情境的話，我的話預計會是再次進行得分表演並補上差額。

      [方案]
      在消除掉落階段外處理 C1 符號的 "贏分計算"與 "判斷觸發 FG" 表演流程上會顯示當所有消除掉落階段(計算贏分符號 -> 處理乘數符號邏輯 -> 補盤) 都結束了之後，再表演 "C1 贏分畫面" 和 "觸發 FG 畫面" 作為最後一動 Step。然後結束這 Round。

- [ ] 生成盤面後，原本 3 顆 C1 在 "消除掉落階段" 出現第 4 顆(有賠率要算分，可以觸發 FG)，盤面上還有一些得分符號要結算，經過消除掉落後，如果又產生了新的得分符號滿足贏分條件 那此時此刻是要 "把這些掉落消除走完" 還是 "走完這次消除掉落後不管補盤有沒有出現贏分組合直接進 FG"?
      [思考]
      感覺這問題要從設定檔那邊去做處理，but How?

      - 你輪帶有辦法控制說如果出現 4 顆以上 C1 後面確保 "不要再出得分符號"?
      - 如果直接在消除掉落階段內 "判斷 C1 數量大於 3 -> break" 會有問題，如果補盤進來又產生新的贏分組合但是又跳走造成盤面邏輯混亂。
      [方案]
      如果在消除掉落階段外判斷 C1 就會導致，C1 符號會停留在盤面上直到消除掉落結束為止，我認為最理想的效果應該是 "C1 大於 3" 之後後面透過 "某一種方式" 不要再出現贏分組合了，這樣流程清晰易懂。

      那這樣的效果要怎麼實現?

- [x] 處理 AddAct 流程，我應該思考前端會怎麼利用這個 `acts` 屬性值
      [問題] 分為 Base Game 和 Free Game 表述之。 Base Game 只有 1 round，2 step(消除掉落階段、C1 算分與判斷觸發 FG)

      1. 驅使盤面變化有兩種可能 一局開始時 "生成初始盤面" 和 "消除掉落與補盤"
      2. 驅使乘數值變化有兩種可能 消除掉落的 "隨機選擇乘數值" 和 "掉落可能觸發乘數升級"
      3. C1 狀態改變，"生成盤面" 和 "補盤" 可能產生數量上的變化，特別注意消除功能 不會消除掉 C1。
      4. 提交要包含 `extend` 的時機
      [方案]
      Base Game

      - 1. 盤面生成(造成盤面產生變化)，提交 `FinishAct` 描述 "GenScreen"
      - 進入到消除掉落階段(每一次 消除掉落就一個 step)
      - 算分 不提交
      - 2. 如果 win 等於 0 代表盤面沒有任何贏分產生，可能會產生兩種情況
        - 如果 `win == 0` ()提交 `FinishStep` 描述 "GenAndCalcScreen"
        - 如果 `win` 有值，繼續進行 "消除掉落階段" -> 處理乘倍值
      - 3. 處理乘倍值會更新 `ext` 狀態與 `win` 值
      - 4. 判斷累積贏分是否大於等於最高贏分上限
        - 如果 "true" 更新當前贏分狀態，並提交 `FinishStep` 描述 "MaxWin"
        - 如果 "false" 更新累積贏分，更新當前贏分狀態，提交 `FinishAct` 描述 "GenAndCalcScreen"
      - 5. 乘數升級(不用一定要掉落才會升級，只要每一次 step 每個乘數符號就有概率升級，可原地升級的意思)
      - 6. 消除掉落，同步 `fix.screen` 和 `screen`， 提交 `FinishStep` 描述 "Gravity"，結束一個 step
      - 7. 補盤，同步 `fix.screen` 和 `screen`。提交 `FinishAct` 描述 "FillScreen"

      Free Game

      進行 n 局 spins
      - 1. 生成盤面，提交 `FinishAct` 描述 "GenScreen"
      - 2.
      -

-[ ] re-trigger 沒做

- [x] `ext` 重構，將 ext pool 改成維護單一 `ext struct`
      [方案] 1. 先把 `exts` 改成 `*extend1801` ，移除 `next()` 因為不需要在 pool 中移動了。對遊戲邏輯的影響是... 2. 然後現在強制必須在 `extend` 實作 `Reset()` 和 `Snapshot()`。`Reset()` 是用來在 base game 跟 free game 重置 `extend` 狀態的。 現在不用 `g.next()` 而是改用 `Reset()`。
      `Snapshot()` 的功能就是 deep clone 當前 `ext` 是用來在 `AddAct()` 這邊...(具體什麼功能要追一下)。

- [ ] 測一下，如果命行下 `mode = 1` 時，輪帶表的選擇是否正確。
      [結果] 目前統計結果看起來沒問題執行 10000 次 spins 會 trigger 10000 次。看起來是沒錯的
      [測試] 輪帶的選擇是否有依照定義去做隨機選擇

- [x] 為了要符合後端那邊的實作流程，在判斷 "累積贏分" 是否大於 "最高贏分上限值" 時需要注意即便達到了贏分上限，還是要把消除掉落的流程走完
      [方案]
      所以需要把跳出機制拉到 "消除掉落" 流程的最上方判斷如果 `maxWinFlag` 則 `break`，`maxWinFlag` 是一個狀態紀錄是否最大上限。

- [ ] 測試 `make test` `svr` "單線" "併發" `go run ./cmd/sim` 都要先跑過
- [ ] 設定檔，輪帶組的設計，拆成兩個來說 base game 需要至少一組沒有乘數符號。 然後 BuyFeaureFree 的 強制觸發 C1 的輪帶組; free game 需要至少一組沒有乘數符號用於當 "累積乘數上限" 滿了之後盤面不能再出現乘數符號。

## 進度

[進度更新] 調整 extend 跟 AddAct() 完成，現在正在測試開 svr 呼叫 spin 結果的 act 有沒有錯誤。然後確認一下 AddAct() 的內容有沒有需要調整的部分

## 今日重點

- 註冊流程更新，`game_registry.go` 的 `gameRegister` 函數的 `gameRegister[T result.ExtendResult]` 原本是 `gameRegister[T any]` 現在強制改成 `result.ExtendResult`。然後原本是 ... 移動到 `extend_result.go` 這邊可以追一下。

- `AddAct()` 最後一個參數從 `g.clone()` 改成放置 `ext` ，除此之外 `ext` struct 必須要有兩個方法 `Reset()` 和 `Snapshot()`。 `Snapshot()` 的功能就是深拷貝一份 `ext`。 但是現在實際執行複製的操作放在 "系統層面" 去處理。

- `make dev` 可以在終端機介面中生成 1 次 spin 的結果，或是數次結果取代 svr 呼叫 spin api 進行測試

## 筆記

- `screen` 跟 `fix.screen` 的差別? `screen` 只儲存符號的索引值(不儲存乘數值的狀態) `fix.screen` 會儲存 乘數符號代表的乘數值，其中 1 代表新的乘數符號索引， +100 代表舊的乘數符號值，所謂舊的意思是指上一個消除掉落狀態。

- `AddAct()` 時機，這邊總共有三個層級 `result.FinishAct`、`result.FinishStep`、`result.FinishRound` 以常數型式儲存。後面三個參數分別是: 自定義描述、screen、ext

- C1 算分時機的問題，會牽涉到 `acts` 如何安排
  [觀察]

  - 因為 Seth 的 C1 只要 4 顆以上就會觸發 Scatter 所以掉落消除後再出現 C1 意義不大(多一顆賠率會變高喔)
  - 我猜這款遊戲精妙的地方應該就是如何設定輪帶表，每個輪帶表具有特殊功能
  - 現在隨機選擇輪帶表可能會抽中有 C1 的那張拿來生成盤面，補盤的時候也要用那張那就有可能會出現補盤的時候 C1 可能會從 4 顆變成 5 顆
  -

- `act`、`step`、`round` 使用時機

  - `act` 盤面或是某個畫面上看的到的狀態值發生變化的時候
  - `step` 消除掉落一次，但是可能會因為各種早停機制消除掉落不一定會是完整的比如說沒有贏分(可是沒有贏分又要補盤)
  - `round` 一局遊戲，從生成盤面 -> 消除掉落循環 -> 結束

- 描述定義

  - "一次 spin" 代表從 base game pay bet 然後 觸發一局 bg spin 這局 spin 可能又會觸發數局 fg spin
  - "一局遊戲" 不管是 bg 還是 fg ，指的是生成盤面到結束動作

- 在消除掉落中，如果 win 等於 0 代表盤面沒有任何贏分產生，可能會產生兩種情況
  [情況 1] 在 paytable C1 沒有值的情況下，消除掉落循環

  - hm 沒有 C1 索引，盤面沒有贏分符號(H1-L5, 不考慮 C1)得分，且 C1 小於 4 -> 退出消除掉落循環
  - hm 沒有 C1 索引，盤面沒有贏分符號(H1-L5, 不考慮 C1)得分，且 C1 大於 4 -> 退出消除掉落循環，在循環外統計 C1 數量算賠率、贏分，提交 act/step
    [情況 2] 在 paytable C1 有值的情況下
  - 如果 C1 又不會被掉落消除(排除掉)，算贏分的時候每次掉落消除會重複計算 C1 贏分，然後 win 有贏分所以會繼續執行，直到最大消除掉落次數。
  - 驗證情況 2 屬實

- `win` 值的意義與變化

- 算分的表演順序是什麼?

  1. 先累積 "得分符號" 贏分加總
  2. 累積 "乘數值" 加總
  3. 計算 "得分符號" 加總 x "乘數值" 加總
     啊 C1 咧?

  4. 得分符號掉落消除跑完了之後(有一個 "得分符號值加總") 這個得分符號值 在跟掉落消除結束之後的盤面上 "乘數符號值加總" 相乘
